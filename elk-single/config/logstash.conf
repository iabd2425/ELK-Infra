input {
  file {
    path => "/usr/share/logstash/data/booking_*_hotels_*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => plain { charset => "UTF-8" }
    # Leer y cerrar, sin monitoreo continuo
    mode => "read"
  }
}

filter {
  # Extraer timestamp, nivel de log y mensaje
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}" }
  }

  date {
    match => [ "timestamp", "yyyy-MM-dd'T'HH:mm:ss" ]
    target => "@timestamp"
  }

  mutate {
    add_field => { "[@metadata][app]" => "mi-aplicacion" }
  }

  ruby {
    code => '
      path = event.get("[log][file][path]")
      if path
        filename = File.basename(path)
        match = filename.match(/booking_(?<city>[a-zA-Z]+)_hotels_\d{2}_\d{2}\.log/)
        if match
          event.set("city", match["city"].downcase)
        else
          event.tag("no_city_match")
        end
      else
        event.tag("no_path_found")
      end
    '
  }

  # Opcional: limpiar campos innecesarios
  mutate {
    remove_field => [ "message", "timestamp" ]
  }
}

output {
  stdout { codec => rubydebug }

  if [city] {
    elasticsearch {
      hosts    => "${ELASTIC_HOSTS}"
      index    => "booking-%{city}"
      user     => "${ELASTIC_USER}"
      password => "${ELASTIC_PASSWORD}"
      cacert   => "certs/ca/ca.crt"
      # Desactiva la funcionalidad de Data Streams y permite utilizar patrones de Ã­ndice tradicionales
      data_stream => false
    }
  } else {
    # fallback opcional
    file {
      path => "/tmp/logstash_unclassified.log"
    }
  }
}
